<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LINAC Output Entry</title>
  <link rel="icon" href="/favicon.png" type="image/png">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable@13.0.0/dist/handsontable.full.min.css" />
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  
  <style>
    /* This inline style block restores the original layout and applies the new fixes */
    body {
      margin: 0;
      font-family: 'Inter', sans-serif;
      background-color: #f5f5f5;
      color: #333;
      display: flex;
      height: 100vh;
      overflow: hidden;
      flex-direction: column;
    }
    .topbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #ffffff;
        padding: 10px 20px;
        border-bottom: 1px solid #ccc;
        box-shadow: 0 2px 4px rgba(0,0,0,0.08);
    }
    .hospital-info-box {
        background-color: #e0f7fa;
        color: #0056b3;
        padding: 8px 15px;
        border-radius: 8px;
        font-weight: 600;
    }
    .topbar .header-buttons {
        display: flex;
        gap: 15px;
        align-items: center;
    }
    .topbar .header-buttons .button, .topbar .header-buttons .header-btn {
        padding: 10px 18px;
        font-size: 1em;
    }
    .topbar .header-buttons .header-btn {
        width: 44px;
        height: 44px;
    }
    .topbar .header-buttons #myProfileBtn {
        background-color: var(--primary-color);
        color: var(--text-white);
    }

    .content {
        display: flex;
        flex: 1;
        overflow: hidden;
    }
    .sidebar {
        width: 200px;
        background: #ffffff;
        padding: 20px;
        box-shadow: 2px 0 5px rgba(0,0,0,0.08);
        display: flex;
        flex-direction: column;
    }
    .sidebar h2 {
        margin: 0 0 20px;
        color: #007bff;
        text-align: center;
    }
    #months {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    #months button {
        width: 100%;
        padding: 12px 0;
        font-size: 1em;
    }

    .main {
        flex-grow: 1;
        padding: 20px;
        overflow: auto; /* This line fixes the layout issue */
    }
    .tab-nav {
        display: flex;
        border-bottom: 2px solid #ccc;
        margin-bottom: 20px;
    }
    .tab-nav-button {
        padding: 10px 20px;
        background-color: transparent;
        border: none;
        cursor: pointer;
        font-size: 1em;
    }
    .tab-nav-button.active {
        border-bottom: 3px solid #007bff;
        font-weight: bold;
    }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    .container {
        display: flex;
        gap: 20px;
        align-items: flex-start;
        flex-wrap: wrap;
    }
    .table-container {
        flex-grow: 1;
        height: 500px;
    }
    .summary-box {
        width: 300px;
        padding: 20px;
        border: 1px solid var(--border-color);
        border-radius: 16px;
        background-color: var(--bg-card);
        box-shadow: 0 4px 12px var(--shadow-light);
    }
    .actions-section, .trend-chart-section {
        text-align: center;
        margin-top: 20px;
    }
    .actions-section button {
        padding: 10px 15px;
        margin: 0 5px;
        border-radius: 5px;
        border: none;
        cursor: pointer;
        color: white;
    }
    .save-btn { background-color: #007bff; }
    .export-btn { background-color: #28a745; }
    
    .chart-wrapper {
        position: relative;
        height: 40vh;
        width: 100%;
    }
    .energy-selector-container {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 15px;
        margin-bottom: 15px;
    }
    .energy-selector-container select {
        max-width: 250px;
        margin: 0;
    }

    #chat-bubble {
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .trend-chart-section {
        position: relative; /* Needed for diagnose button */
        padding: 20px;
        border: 1px solid var(--border-color);
        border-radius: 16px;
        background-color: var(--bg-card);
        box-shadow: 0 4px 12px var(--shadow-light);
    }
    #annotationModal .modal-buttons button {
        padding: 12px 25px;
        font-size: 1em;
    }
    #annotationModal textarea {
        width: 100%;
        min-height: 120px;
        resize: vertical;
    }
    #deleteAnnotationBtn {
        background-color: var(--status-error);
    }

    .chart-actions-container {
        position: absolute;
        top: 15px;
        right: 15px;
        display: flex;
        gap: 10px;
        z-index: 10;
    }

    .diagnose-btn, .validate-btn {
        position: static;
        color: var(--text-main);
        padding: 8px 12px;
        font-size: 0.9em;
        border-radius: 6px;
        z-index: 10;
        border: none;
        cursor: pointer;
    }

    .diagnose-btn { background-color: var(--status-warning); }
    .validate-btn { background-color: #17a2b8; color: white; }
    
    .diagnose-btn:hover { background-color: #ffca2c; }
    .validate-btn:hover { background-color: #138496; }
  </style>
</head>
<body class="upload-page">
  <div class="topbar">
    <button id="menu-toggle" class="header-btn menu-toggle-btn"><i class="fas fa-bars"></i></button>
    <div id="hospitalInfoBox" class="hospital-info-box">Hospital: <span id="hospitalName"></span></div>
    <div class="header-buttons">
        <a href="my_profile.html" id="myProfileBtn" class="button">My Profile</a>
        <button id="logoutBtn" title="Logout" aria-label="Logout" class="header-btn" style="background-color: var(--status-error); color: white;"><i class="fas fa-sign-out-alt"></i></button>
    </div>
  </div>
  <div class="content">
    <div class="sidebar">
      <h2>LINAC QA</h2>
     <div class="year-nav">
        <button id="prevYearBtn" aria-label="Previous Year">&lt;</button>
        <span id="year">2025</span>
        <button id="nextYearBtn" aria-label="Next Year">&gt;</button>
    </div>
      <div id="months"></div>
      <label style="margin-top: auto; padding-top: 20px;"><input type="checkbox" id="darkToggle"> Dark Mode</label>
      <p>© 2025 QA Dashboard</p>
    </div>
    <div class="main">
      <div class="main-header-controls">
        <div class="header-spacer-left"></div>
        <h1 id="header"></h1>
        <div id="dailyCheckPanel" class="daily-check-box">
          <h3>Daily check</h3>
          <div id="selected-date-display">Select a date column</div>
          <div class="daily-check-inputs">
              <div class="form-group">
                  <label for="daily-temp">Temp (°C)</label>
                  <input type="number" id="daily-temp" placeholder="--" disabled>
              </div>
              <div class="form-group">
                  <label for="daily-pressure">Pressure (hPa)</label>
                  <input type="number" id="daily-pressure" placeholder="--" disabled>
              </div>
          </div>
        </div>
      </div>

      <div class="tab-nav">
        <button class="tab-nav-button active" onclick="switchTab('output')">Output</button>
        <button class="tab-nav-button" onclick="switchTab('flatness')">Flatness</button>
        <button class="tab-nav-button" onclick="switchTab('inline')">Inline Symmetry</button>
        <button class="tab-nav-button" onclick="switchTab('crossline')">Crossline Symmetry</button>
      </div>
      <div id="tab-content-output" class="tab-content active"></div>
      <div id="tab-content-flatness" class="tab-content"></div>
      <div id="tab-content-inline" class="tab-content"></div>
      <div id="tab-content-crossline" class="tab-content"></div>
    </div>
  </div>
  <div id="loading-overlay"><div class="spinner"></div></div>
  <div id="chat-bubble"><i class="fas fa-comment-dots"></i></div>
  <div id="chat-window">
    <div id="chat-header"><span>QA Copilot</span><button id="close-chat-btn">&times;</button></div>
    <div id="chat-body"><div class="chat-message bot">Hello! Ask me about your data.</div></div>
    <div id="chat-input-area"><input type="text" id="chat-input" placeholder="Type..."><button id="send-chat-btn">&gt;</button></div>
    <div id="chat-options-area"></div>
  </div>

  <div id="annotationModal" class="modal">
    <div class="modal-content">
        <span class="close-button" onclick="hideAnnotationModal()">&times;</span>
        <h3 id="annotationModalTitle">Add/Edit Annotation</h3>
        <textarea id="annotationInput" placeholder="Enter your note here..."></textarea>
        <div class="service-day-checkbox">
            <input type="checkbox" id="isServiceDayInput">
            <label for="isServiceDayInput">Mark as Service/Calibration Day</label>
        </div>
        <div class="modal-buttons">
            <button id="deleteAnnotationBtn" class="button" style="display: none;">Delete Note</button>
            <button id="saveAnnotationBtn" class="save-btn">Save Note</button>
            <button class="cancel-btn" onclick="hideAnnotationModal()">Cancel</button>
        </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/handsontable@13.0.0/dist/handsontable.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-check-compat.js"></script>
  <script src="firebase-init.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore-compat.js"></script>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
        const auth = firebase.auth();
        const db = firebase.firestore();
        const appCheck = firebase.appCheck();
        const BACKEND_URL = "https://back-end-wrxi.onrender.com";
        let currentUID, currentHospital;
        let currentDate = new Date();
        currentDate.setDate(1);
        let lastDataMonth = null; 
        let monthlyEnvData = {};
        // --- [NEW] Variable to track custom highlighting ---
        let highlightedColumnIndex = -1;

        const energyTypes = ["6X", "10X", "15X", "6X FFF", "10X FFF", "6E", "9E", "12E", "15E", "18E"];
        const dataTypesConfig = {
          output: { label: 'Output', tolerance: 2.0, warning: 1.8, initialized: false, yAxisMin: -3, yAxisMax: 3 },
          flatness: { label: 'Flatness', tolerance: 1.0, warning: 0.9, initialized: false, yAxisMin: -2, yAxisMax: 2 },
          inline: { label: 'Inline Symmetry', tolerance: 1.0, warning: 0.9, initialized: false, yAxisMin: -2, yAxisMax: 2 },
          crossline: { label: 'Crossline Symmetry', tolerance: 1.0, warning: 0.9, initialized: false, yAxisMin: -2, yAxisMax: 2 }
        };
        let instances = { output: {}, flatness: {}, inline: {}, crossline: {} };
        let activeTab = 'output';
        const yearLabel = document.getElementById('year');
        const monthsDiv = document.getElementById('months');
        const header = document.getElementById('header');
        
        const annotationModal = document.getElementById('annotationModal');
        const annotationModalTitle = document.getElementById('annotationModalTitle');
        const annotationInput = document.getElementById('annotationInput');
        const saveAnnotationBtn = document.getElementById('saveAnnotationBtn');
        const deleteAnnotationBtn = document.getElementById('deleteAnnotationBtn');
        const isServiceDayInput = document.getElementById('isServiceDayInput');
        let currentAnnotationKey = null;

        const chatWindow = document.getElementById('chat-window');
        const chatBody = document.getElementById('chat-body');
        const chatInput = document.getElementById('chat-input');
        const chatOptionsArea = document.getElementById('chat-options-area');
        let diagnosticState = {
            inProgress: false,
            topic: null,
            node_id: null
        };
        let proactiveChatListener = null;

        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        }

        function showLoader() { document.getElementById('loading-overlay').style.display = 'flex'; }
        function hideLoader() { document.getElementById('loading-overlay').style.display = 'none'; }
        
        function showNotification(message, type = 'info', duration = 3000) {
            const container = document.getElementById('notification-container');
            if (!container) return;
            const notification = document.createElement('div');
            notification.className = `notification-message ${type} show`;
            notification.textContent = message;
            container.appendChild(notification);
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 500);
            }, duration);
        }

        async function logout() {
            showLoader();
            try {
                const user = auth.currentUser;
                const appCheckTokenResponse = await appCheck.getToken(false);
                await fetch(`${BACKEND_URL}/log_event`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json", "X-Firebase-AppCheck": appCheckTokenResponse.token },
                    body: JSON.stringify({ action: "user_logout", userUid: user ? user.uid : "unknown_uid" })
                });
            } catch (logError) { 
                console.error("Error sending logout log event:", logError); 
            }
            
            auth.signOut().then(() => {
                localStorage.clear();
                window.location.replace("login.html");
            }).catch(err => {
                hideLoader();
            });
        }
        window.logout = logout;

        function generateTabContentHTML(dataType) {
            const config = dataTypesConfig[dataType];
            return `
                <div class="container">
                    <div id="table-${dataType}" class="table-container"></div>
                    <div class="summary-box">
                        <h3>${config.label} Summary</h3>
                        <canvas id="summaryChart-${dataType}"></canvas>
                        <p>Total Entries: <span id="total-${dataType}">0</span></p>
                        <p>Within Tolerance: <span id="within-${dataType}">0</span></p>
                        <p>Warning: <span id="warning-${dataType}">0</span></p>
                        <p>Out of Tolerance: <span id="out-${dataType}">0</span></p>
                    </div>
                </div>
                <div class="actions-section">
                    <button class="save-btn" onclick="manualSave('${dataType}')">Save ${config.label}</button>
                    <button class="export-btn" onclick="exportToExcel('${dataType}')">Export ${config.label}</button>
                    <span id="lastSaved-${dataType}"></span>
                </div>
                <div class="trend-chart-section" id="trend-section-${dataType}">
                    <h3>${config.label} Trend Analysis</h3>
                    <div class="energy-selector-container">
                        <label>Select Energy:</label>
                        <select id="trendEnergySelect-${dataType}"></select>
                    </div>
                    <div class="chart-wrapper">
                        <canvas id="trendChart-${dataType}"></canvas>
                    </div>
                </div>
            `;
        }
        
        const saveEnvData = debounce(async () => {
            const dateDisplay = document.getElementById('selected-date-display');
            const fullDate = dateDisplay.dataset.fullDate;
            if (!fullDate) return;

            const temp = document.getElementById('daily-temp').value;
            const pressure = document.getElementById('daily-pressure').value;
            
            if (!monthlyEnvData[fullDate]) monthlyEnvData[fullDate] = {};
            monthlyEnvData[fullDate].temperature_celsius = temp ? parseFloat(temp) : null;
            monthlyEnvData[fullDate].pressure_hpa = pressure ? parseFloat(pressure) : null;
            
            try {
                const appCheckToken = (await appCheck.getToken(false)).token;
                await fetch(`${BACKEND_URL}/save-daily-env`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-Firebase-AppCheck': appCheckToken },
                    body: JSON.stringify({
                        uid: currentUID,
                        date: fullDate,
                        temperature: temp,
                        pressure: pressure
                    })
                });
                showNotification(`Vitals for ${fullDate} saved.`, 'success', 1500);
            } catch (error) {
                console.error("Failed to save environmental data:", error);
                showNotification(`Failed to save vitals for ${fullDate}.`, 'error');
            }
        }, 1000);

        // --- [BUG FIX] This function now clears custom highlights ---
        function handleGridSelection(col) {
            const dateDisplay = document.getElementById('selected-date-display');
            const tempInput = document.getElementById('daily-temp');
            const pressureInput = document.getElementById('daily-pressure');
            
            clearColumnHighlight(); // Clear any custom highlight when user clicks the grid

            if (col === 0 || col === -1) {
                dateDisplay.textContent = 'Select a date column';
                dateDisplay.dataset.fullDate = '';
                tempInput.value = '';
                pressureInput.value = '';
                tempInput.disabled = true;
                pressureInput.disabled = true;
                return;
            }
            
            const fullDate = getMonthDates(currentDate)[col - 1];

            if (fullDate) {
                dateDisplay.textContent = `Editing for: ${fullDate}`;
                dateDisplay.dataset.fullDate = fullDate;
                
                const dayData = monthlyEnvData[fullDate] || {};
                tempInput.value = dayData.temperature_celsius || '';
                pressureInput.value = dayData.pressure_hpa || '';

                tempInput.disabled = false;
                pressureInput.disabled = false;
            }
        }

        // --- [MODIFIED] Highlighting is now done by adding/removing a CSS class ---
        function highlightColumnFromPanel() {
            const hot = instances[activeTab].hot;
            if (!hot) return;
            const fullDate = document.getElementById('selected-date-display').dataset.fullDate;
            if (!fullDate) return;

            const dateHeaders = getMonthDates(currentDate);
            const dateIndex = dateHeaders.indexOf(fullDate);
            if (dateIndex !== -1) {
                const columnIndex = dateIndex + 1;
                highlightedColumnIndex = columnIndex;
                hot.render(); // Force re-render to apply new class
            }
        }

        function clearColumnHighlight() {
            if (highlightedColumnIndex !== -1) {
                highlightedColumnIndex = -1;
                const hot = instances[activeTab].hot;
                if (hot) {
                    hot.render();
                }
            }
        }

        window.switchTab = async function(dataType) {
            activeTab = dataType;
            document.querySelectorAll('.tab-nav-button').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[onclick="switchTab('${dataType}')"]`).classList.add('active');
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`tab-content-${dataType}`).classList.add('active');
            if (!dataTypesConfig[dataType].initialized) {
                await initializeTab(dataType);
            }
        }

        async function initializeTab(dataType) {
            showLoader();
            document.getElementById(`tab-content-${dataType}`).innerHTML = generateTabContentHTML(dataType);
            populateTrendEnergySelect(dataType);
            document.getElementById(`trendEnergySelect-${dataType}`).addEventListener('change', updateTrendChart);
            
            await loadDataForTab(dataType);
            dataTypesConfig[dataType].initialized = true;
            hideLoader();
        }

        async function loadDataForTab(dataType) {
            showLoader();
            const config = dataTypesConfig[dataType];
            const monthKey = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
            try {
                const appCheckTokenResponse = await appCheck.getToken(false);
                const res = await fetch(`${BACKEND_URL}/data?month=${monthKey}&uid=${currentUID}&dataType=${dataType}`, {
                    headers: { "X-Firebase-AppCheck": appCheckTokenResponse.token }
                });
                if (!res.ok) throw new Error(`Server error: ${res.statusText}`);
                const result = await res.json();
                
                monthlyEnvData = result.env_data || {};
                
                const dateCols = getMonthDates(currentDate);
                let data = Array.isArray(result.data) && result.data.length > 0
                    ? result.data.map(r => r.map(c => c === null || c === "None" ? "" : c))
                    : energyTypes.map(e => [e, ...new Array(dateCols.length).fill('')]);
                
                const columnsConfig = [{ type: 'text', readOnly: true }];
                for (let i = 0; i < dateCols.length; i++) {
                    columnsConfig.push({
                        type: 'numeric',
                        numericFormat: { pattern: '0.00' },
                        allowInvalid: false,
                        allowEmpty: true
                    });
                }

                const container = document.getElementById(`table-${dataType}`);
                if (instances[dataType].hot) instances[dataType].hot.destroy();
                instances[dataType].hot = new Handsontable(container, {
                    data, rowHeaders: false, height: 500, licenseKey: 'non-commercial-and-evaluation',
                    colHeaders: i => i === 0 ? 'Energy' : dateCols[i - 1]?.split('-')[2] || '',
                    colWidths: (index) => {
                        return index === 0 ? 100 : 65;
                    },
                    columns: columnsConfig,
                    afterChange: (changes, source) => {
                        if (source !== 'loadData') {
                            updateSummaryAndChart(dataType, instances[dataType].hot.getData());
                            updateTrendChart();
                        }
                    },
                    afterSelection: (row, col, row2, col2) => {
                        handleGridSelection(col);
                    },
                    // [MODIFIED] Cells function now checks for the custom highlight class
                    cells: function (r, c) {
                        const props = { readOnly: false, className: '' };
                        if (c === 0) props.readOnly = true;
                        
                        // Add custom highlight class if needed
                        if (c === highlightedColumnIndex) {
                            props.className += ' highlighted-col';
                        }

                        const today = new Date();
                        const isFuture = currentDate.getFullYear() > today.getFullYear() ||
                                       (currentDate.getFullYear() === today.getFullYear() && currentDate.getMonth() > today.getMonth()) ||
                                       (currentDate.getFullYear() === today.getFullYear() && currentDate.getMonth() === today.getMonth() && c > today.getDate());
                        if (isFuture) {
                            props.readOnly = true;
                            props.className += ' future-cell-readonly';
                        } else {
                            const val = parseFloat(this.instance.getDataAtCell(r, c));
                            if (!isNaN(val)) {
                                if (Math.abs(val) < config.warning) props.className += ' within';
                                else if (Math.abs(val) <= config.tolerance) props.className += ' warning';
                                else props.className += ' out';
                            }
                        }
                        return props;
                    }
                });
                updateSummaryAndChart(dataType, data);
                updateTrendChart();
            } catch (e) { console.error(`Error loading data for ${dataType}:`, e); } finally { hideLoader(); }
        }

        async function checkAndSendAlerts(dataType) {
            const config = dataTypesConfig[dataType];
            const hotInstance = instances[dataType].hot;
            if (!hotInstance) return;

            const data = hotInstance.getData();
            const dateHeaders = getMonthDates(currentDate);
            const outOfToleranceValues = [];

            data.forEach(row => {
                const energy = row[0];
                row.slice(1).forEach((value, index) => {
                    const numValue = parseFloat(value);
                    if (!isNaN(numValue) && Math.abs(numValue) > config.tolerance) {
                        outOfToleranceValues.push({
                            energy: energy,
                            date: dateHeaders[index],
                            value: numValue
                        });
                    }
                });
            });

            if (outOfToleranceValues.length > 0) {
                console.log("Out of tolerance values detected, sending alert...", outOfToleranceValues);
                try {
                    const appCheckTokenResponse = await appCheck.getToken(false);
                    const monthKey = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
                    const response = await fetch(`${BACKEND_URL}/send-alert`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Firebase-AppCheck': appCheckTokenResponse.token
                        },
                        body: JSON.stringify({
                            uid: currentUID,
                            hospitalName: currentHospital,
                            month: monthKey,
                            dataType: dataType,
                            tolerance: config.tolerance,
                            outValues: outOfToleranceValues
                        })
                    });
                    const result = await response.json();
                    if (result.status === 'alert sent') {
                        showNotification(`Alert sent for ${outOfToleranceValues.length} out-of-tolerance value(s).`, 'success');
                    } else if (result.status === 'no_change') {
                         console.log("Alert status has not changed since last save. No new email sent.");
                    }
                } catch (error) {
                    console.error("Failed to send alert:", error);
                    showNotification("Failed to send alert email.", 'error');
                }
            } else {
                 console.log("No out of tolerance values found.");
            }
        }

        window.manualSave = async function(dataType) {
            const saveButton = document.querySelector(`.actions-section button.save-btn[onclick="manualSave('${dataType}')"]`);
            const config = dataTypesConfig[dataType];
            saveButton.disabled = true;
            saveButton.textContent = 'Saving...';
            const changedData = instances[dataType].hot.getData();
            const month = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
            try {
                const appCheckTokenResponse = await appCheck.getToken(false);
                const token = appCheckTokenResponse.token;
                const saveResponse = await fetch(`${BACKEND_URL}/save`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json', "X-Firebase-AppCheck": token },
                    body: JSON.stringify({ data: changedData, month, uid: currentUID, dataType: dataType })
                });
                if (!saveResponse.ok) { throw new Error(`Save failed: ${await saveResponse.text()}`); }
                document.getElementById(`lastSaved-${dataType}`).textContent = "Saved: " + new Date().toLocaleTimeString();
                
                lastDataMonth = month;
                updateTrendChart(); 

                await checkAndSendAlerts(dataType);

            } catch (err) {
                console.error(`Save process failed for ${dataType}:`, err);
                document.getElementById(`lastSaved-${dataType}`).textContent = "Save Failed!";
            } finally {
                saveButton.disabled = false;
                saveButton.textContent = `Save ${config.label}`;
            }
        }
        
        window.exportToExcel = async function(dataType) {
            showLoader();
            const month = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
            try {
                const appCheckTokenResponse = await appCheck.getToken(false);
                const response = await fetch(`${BACKEND_URL}/export-excel`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', "X-Firebase-AppCheck": appCheckTokenResponse.token },
                    body: JSON.stringify({ month, uid: currentUID, dataType })
                });
                if (!response.ok) throw new Error('Failed to generate file.');
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `LINAC_QA_${dataType.toUpperCase()}_${month}.xlsx`;
                document.body.appendChild(a);
                a.click();
                a.remove();
                window.URL.revokeObjectURL(url);
            } catch (error) {
                console.error(`Export failed for ${dataType}:`, error);
            } finally {
                hideLoader();
            }
        }
        
        function updateSummaryAndChart(dataType, data) {
            const config = dataTypesConfig[dataType];
            let total = 0, within = 0, warning = 0, out = 0;
            data.forEach(row => {
                row.slice(1).forEach(value => {
                    const n = parseFloat(value);
                    if (!isNaN(n)) {
                        total++;
                        if (Math.abs(n) < config.warning) within++;
                        else if (Math.abs(n) <= config.tolerance) warning++;
                        else out++;
                    }
                });
            });
            document.getElementById(`total-${dataType}`).textContent = total;
            document.getElementById(`within-${dataType}`).textContent = within;
            document.getElementById(`warning-${dataType}`).textContent = warning;
            document.getElementById(`out-${dataType}`).textContent = out;
            const ctx = document.getElementById(`summaryChart-${dataType}`).getContext('2d');
            if (instances[dataType].summaryChart) instances[dataType].summaryChart.destroy();

            const legendColor = document.body.classList.contains('dark') ? 'white' : '#666';

            instances[dataType].summaryChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: ['Within', 'Warning', 'Out of Tolerance'],
                    datasets: [{ data: [within, warning, out], backgroundColor: ['#66cc66', '#ffcc00', '#ff6666'] }]
                },
                options: { 
                    responsive: true, 
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            labels: {
                                color: legendColor
                            }
                        }
                    }
                }
            });
        }
        
        function populateTrendEnergySelect(dataType) {
            const select = document.getElementById(`trendEnergySelect-${dataType}`);
            if(!select) return;
            select.innerHTML = '';
            energyTypes.forEach(energy => {
                const option = document.createElement('option');
                option.value = energy;
                option.textContent = energy;
                select.appendChild(option);
            });
            if (energyTypes.length > 0) select.value = energyTypes[0];
        }

        async function showAnnotationModal(key, existingText, energy, date) {
            currentAnnotationKey = key;
            annotationModalTitle.textContent = `Note for ${energy} on ${date}`;
            annotationInput.value = existingText;

            const serviceEventRef = db.collection('service_events').doc(currentUID).collection('events').doc(date);
            const serviceEventSnap = await serviceEventRef.get();
            isServiceDayInput.checked = serviceEventSnap.exists;

            if (existingText || isServiceDayInput.checked) {
                deleteAnnotationBtn.style.display = 'inline-flex';
            } else {
                deleteAnnotationBtn.style.display = 'none';
            }
            annotationModal.style.display = 'flex';
        }

        window.hideAnnotationModal = function() {
            annotationModal.style.display = 'none';
            currentAnnotationKey = null;
        }
        
        saveAnnotationBtn.addEventListener('click', async () => {
            if (!currentAnnotationKey) return;
            const note = annotationInput.value;
            const isServiceDay = isServiceDayInput.checked;
            const monthKey = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
            const fullDate = currentAnnotationKey.split('-').slice(1).join('-');

            showLoader();
            try {
                const appCheckTokenResponse = await appCheck.getToken(false);
                await fetch(`${BACKEND_URL}/save-annotation`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', "X-Firebase-AppCheck": appCheckTokenResponse.token },
                    body: JSON.stringify({
                        uid: currentUID,
                        month: monthKey,
                        key: currentAnnotationKey,
                        data: { 
                            text: note, 
                            dataType: activeTab, 
                            energy: currentAnnotationKey.split('-')[0],
                            isServiceEvent: isServiceDay, 
                            eventDate: fullDate
                        }
                    })
                });
                hideAnnotationModal();
                await updateTrendChart(); 
            } catch (e) { console.error("Failed to save annotation", e); } 
            finally { hideLoader(); }
        });

        deleteAnnotationBtn.addEventListener('click', async () => {
            if (!currentAnnotationKey) return;
            const monthKey = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
            showLoader();
            try {
                const appCheckTokenResponse = await appCheck.getToken(false);
                await fetch(`${BACKEND_URL}/delete-annotation`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', "X-Firebase-AppCheck": appCheckTokenResponse.token },
                    body: JSON.stringify({
                        uid: currentUID, month: monthKey, key: currentAnnotationKey
                    })
                });
                hideAnnotationModal();
                await updateTrendChart(); 
            } catch (e) { console.error("Failed to delete annotation", e); } 
            finally { hideLoader(); }
        });
        
        window.validatePrediction = async function() {
            const dataType = activeTab;
            showLoader();
            const selectedEnergy = document.getElementById(`trendEnergySelect-${dataType}`).value;
            const monthKey = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
            const button = document.getElementById(`validateBtn-${dataType}`);
            
            try {
                const appCheckTokenResponse = await appCheck.getToken(false);
                const response = await fetch(`${BACKEND_URL}/historical-forecast`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-Firebase-AppCheck': appCheckTokenResponse.token },
                    body: JSON.stringify({ uid: currentUID, month: monthKey, dataType: dataType, energy: selectedEnergy })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to generate historical forecast.');
                }

                const result = await response.json();
                await updateTrendChart(result);
                if (button) button.disabled = true;

            } catch (error) {
                alert(`Error: ${error.message}`);
                if (button) button.disabled = false;
            } finally {
                hideLoader();
            }
        };

        async function updateTrendChart(passedData = null) {
            const dataType = activeTab;
            const hotInstance = instances[dataType].hot;
            if (!hotInstance) return;

            const data = hotInstance.getData();
            const selectElement = document.getElementById(`trendEnergySelect-${dataType}`);
            if (!selectElement) return;

            const selectedEnergy = selectElement.value;
            const energyRow = data.find(row => row[0] === selectedEnergy);
            const historicalPoints = energyRow ? energyRow.slice(1).map(val => { const num = parseFloat(val); return isFinite(num) ? num : null; }) : [];
            
            const hasData = historicalPoints.some(point => point !== null);
            let historicalLabels = getMonthDates(currentDate).map(d => {
                const dateParts = d.split('-');
                return `${parseInt(dateParts[2])}`;
            });
            
            const viewingMonthKey = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
            const isPastMonth = lastDataMonth ? viewingMonthKey < lastDataMonth : false;
            
            const datasets = [{
                label: `${selectedEnergy} Historical`, data: historicalPoints,
                borderColor: '#007bff', backgroundColor: '#007bff',
                tension: 0.1, spanGaps: true
            }];
            let allLabels = [...historicalLabels];
            let forecastData = [];
            let validationActuals = [];
            let forecastLabel = 'Forecast';

            if (passedData) {
                forecastData = (passedData.forecast || []).map(p => {
                    if (p && p.ds) {
                        return {
                            date: p.ds.substring(0, 10),
                            predicted_value: p.yhat,
                            lower_bound: p.yhat_lower,
                            upper_bound: p.yhat_upper
                        };
                    }
                    return null;
                }).filter(Boolean);
                validationActuals = passedData.actuals || [];
                forecastLabel = 'Historical Forecast';
            } else { 
                try {
                    const appCheckTokenResponse = await appCheck.getToken(false);
                    const token = appCheckTokenResponse.token;
                    const res = await fetch(`${BACKEND_URL}/predictions?uid=${currentUID}&dataType=${dataType}&energy=${selectedEnergy}&month=${viewingMonthKey}`, { headers: { "X-Firebase-AppCheck": token } });
                    if (res.ok) {
                        const forecastResult = await res.json();
                        forecastData = forecastResult.forecast || [];
                    }
                } catch (e) { console.error("Could not fetch predictions", e); }
            }
            
            if (forecastData.length > 0) {
                const predictionLine = new Array(historicalPoints.length).fill(null);
                const lowerBand = new Array(historicalPoints.length).fill(null);
                const upperBand = new Array(historicalPoints.length).fill(null);

                forecastData.forEach(p => {
                    if (p && p.date) {
                        const dayIndex = parseInt(p.date.split('-')[2], 10) - 1;
                        if(dayIndex >= 0 && dayIndex < predictionLine.length) {
                           predictionLine[dayIndex] = p.predicted_value;
                           lowerBand[dayIndex] = p.lower_bound;
                           upperBand[dayIndex] = p.upper_bound;
                        }
                    }
                });
                
                datasets.push({ label: forecastLabel, data: predictionLine, borderColor: 'rgba(255, 99, 132, 1)', borderDash: [5, 5] });
                datasets.push({ label: 'Confidence Interval', data: upperBand, fill: '+1', backgroundColor: 'rgba(255, 99, 132, 0.2)', borderColor: 'transparent', pointRadius: 0 });
                datasets.push({ label: 'Confidence Interval (Lower)', data: lowerBand, borderColor: 'transparent', pointRadius: 0, fill: false });
            }

            if (validationActuals.length > 0) {
                datasets.push({ label: 'Validation Actuals', data: validationActuals, borderColor: 'rgba(108, 117, 125, 1)', tension: 0.1 });
            }
            
            const trendSection = document.getElementById(`trend-section-${dataType}`);
            let existingActions = trendSection.querySelector('.chart-actions-container');
            if (existingActions) existingActions.remove();

            const actionsContainer = document.createElement('div');
            actionsContainer.className = 'chart-actions-container';

            if (hasData && isPastMonth) {
                const validateBtn = document.createElement('button');
                validateBtn.className = 'validate-btn';
                validateBtn.id = `validateBtn-${dataType}`;
                validateBtn.innerHTML = '<i class="fas fa-history"></i> Validate Prediction';
                validateBtn.onclick = () => validatePrediction();
                actionsContainer.appendChild(validateBtn);
            }
            
            if (actionsContainer.hasChildNodes()) {
                trendSection.prepend(actionsContainer);
            }
            
            let annotations = {};
            annotations['zeroBaseline'] = { type: 'line', yMin: 0, yMax: 0, borderColor: 'rgba(0, 0, 0, 0.8)', borderWidth: 1.5, borderDash: [6, 6] };
            
            try {
                const serviceEventsRef = db.collection('service_events').doc(currentUID).collection('events');
                const querySnapshot = await serviceEventsRef.get();
                querySnapshot.forEach(doc => {
                    const dateParts = doc.id.split('-');
                    const eventYear = parseInt(dateParts[0]);
                    const eventMonth = parseInt(dateParts[1]) - 1;
                    const eventDay = dateParts[2];

                    if (eventYear === currentDate.getFullYear() && eventMonth === currentDate.getMonth()) {
                        const annotationKey = `serviceDay-${doc.id}`;
                        annotations[annotationKey] = {
                            type: 'line',
                            scaleID: 'x',
                            value: String(parseInt(eventDay)),
                            borderColor: 'rgba(220, 53, 69, 0.8)',
                            borderWidth: 2,
                            borderDash: [10, 5],
                            label: { content: 'Service', display: true, position: 'start', backgroundColor: 'rgba(220, 53, 69, 0.8)', color: 'white', font: { size: 10 } }
                        };
                    }
                });
            } catch (error) { console.error("Error fetching service events for chart annotations:", error); }

            try {
                const notesSnapshot = await db.collection('annotations').doc(currentUID).collection(viewingMonthKey)
                    .where('energy', '==', selectedEnergy)
                    .get();
                    
                notesSnapshot.forEach(doc => {
                    const noteData = doc.data();
                    const noteKey = doc.id; 
                    const dateParts = noteKey.split('-');
                    const day = parseInt(dateParts[3]);
                    const yValue = historicalPoints[day - 1];

                    if (noteData.text && yValue !== null) {
                        annotations[noteKey] = {
                            type: 'point', xValue: day, yValue: yValue, backgroundColor: 'rgba(0, 123, 255, 0.7)', radius: 5,
                            label: { content: noteData.text, display: 'auto', backgroundColor: 'rgba(0, 0, 0, 0.8)', color: 'white', padding: 6, borderRadius: 6, yAdjust: -15 }
                        };
                    }
                });
            } catch (error) { console.error("Error fetching text notes for chart:", error); }

            if (forecastData.length > 0) {
                const redFlagPoints = historicalPoints.map((actualValue, index) => {
                    const day = index + 1;
                    const dateToFind = `${viewingMonthKey}-${String(day).padStart(2, '0')}`;
                    const forecastForDay = forecastData.find(f => f.date === dateToFind);
                    if (actualValue !== null && isFinite(actualValue) && forecastForDay) {
                        if (actualValue < forecastForDay.lower_bound || actualValue > forecastForDay.upper_bound) {
                            return actualValue;
                        }
                    }
                    return null;
                });

                datasets.push({
                    label: 'Flagged Deviation', data: redFlagPoints, pointStyle: 'triangle', radius: 8,
                    rotation: (context) => {
                        const day = context.dataIndex + 1;
                        const dateToFind = `${viewingMonthKey}-${String(day).padStart(2, '0')}`;
                        const forecastForDay = forecastData.find(f => f.date === dateToFind);
                        return (forecastForDay && context.raw > forecastForDay.upper_bound) ? 0 : 180;
                    },
                    backgroundColor: 'rgba(220, 53, 69, 0.9)', borderColor: 'rgba(220, 53, 69, 0.9)', showLine: false
                });
            }

            const canvasElement = document.getElementById(`trendChart-${dataType}`);
            const config = dataTypesConfig[dataType];
            const ctx = canvasElement.getContext('2d');
            if (instances[dataType].trendChart) instances[dataType].trendChart.destroy();
            
            const isDarkMode = document.body.classList.contains('dark');
            const ticksColor = isDarkMode ? '#ddd' : '#666';
            const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';

            instances[dataType].trendChart = new Chart(ctx, {
                type: 'line', data: { labels: allLabels, datasets: datasets },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        y: { min: config.yAxisMin, max: config.yAxisMax, title: { display: true, text: 'Deviation (%)', color: ticksColor }, grid: { color: gridColor }, ticks: { color: ticksColor } },
                        x: { title: { display: true, text: `Day of Month`, color: ticksColor }, grid: { color: gridColor }, ticks: { color: ticksColor } }
                    },
                    plugins: {
                        legend: { labels: { color: ticksColor } },
                        annotation: { annotations: annotations },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) { label += ': '; }
                                    if (context.parsed.y !== null) { label += context.parsed.y.toFixed(2) + '%'; }
                                    if (context.dataset.label === 'Flagged Deviation') {
                                        const day = context.dataIndex + 1;
                                        const dateToFind = `${viewingMonthKey}-${String(day).padStart(2, '0')}`;
                                        const forecastForDay = forecastData.find(f => f.date === dateToFind);
                                        if (forecastForDay) {
                                            label += ` (Interval: [${forecastForDay.lower_bound.toFixed(2)}, ${forecastForDay.upper_bound.toFixed(2)}])`;
                                        }
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    onClick: async (e) => {
                        const points = instances[dataType].trendChart.getElementsAtEventForMode(e, 'nearest', { intersect: true }, true);
                        if (points.length) {
                            const firstPoint = points[0];
                            const dateLabel = instances[dataType].trendChart.data.labels[firstPoint.index];
                            const selectedEnergy = document.getElementById(`trendEnergySelect-${dataType}`).value;
                            const fullDate = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}-${String(dateLabel).padStart(2, '0')}`;
                            const key = `${selectedEnergy}-${fullDate}`;
                            
                            const monthKey = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
                            let existingText = '';
                            try {
                                const annotationRef = db.collection('annotations').doc(currentUID).collection(monthKey).doc(key);
                                const doc = await annotationRef.get();
                                if (doc.exists) {
                                    existingText = doc.data().text || '';
                                }
                            } catch (error) { console.error("Error fetching existing annotation:", error); }
                            showAnnotationModal(key, existingText, selectedEnergy, fullDate);
                        }
                    }
                }
            });
        };
        
        function appendChatMessage(message, sender) {
            const msgDiv = document.createElement('div');
            msgDiv.classList.add('chat-message', sender);
            msgDiv.textContent = message;
            chatBody.appendChild(msgDiv);
            chatBody.scrollTop = chatBody.scrollHeight;
        }

        function showChatOptions(options, callback) {
            chatOptionsArea.innerHTML = '';
            if (options && options.length > 0) {
                options.forEach(optionText => {
                    const button = document.createElement('button');
                    button.textContent = optionText;
                    button.onclick = () => {
                        appendChatMessage(optionText, 'user');
                        chatOptionsArea.innerHTML = '';
                        callback(optionText);
                    };
                    chatOptionsArea.appendChild(button);
                });
            }
        }

        async function sendChatMessage(text = null) {
            const queryText = text || chatInput.value.trim();
            if (queryText === "") return;
            appendChatMessage(queryText, 'user');
            chatInput.value = '';
            
            try {
                const appCheckToken = (await appCheck.getToken(false)).token;
                const response = await fetch(`${BACKEND_URL}/query-qa-data`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-Firebase-AppCheck': appCheckToken },
                    body: JSON.stringify({ query_text: queryText })
                });
                const data = await response.json();

                if (data.status === 'diagnostic_start') {
                    diagnosticState.inProgress = true;
                    diagnosticState.topic = data.topic;
                    diagnosticState.node_id = data.node_id;
                    appendChatMessage(data.question, 'bot');
                    showChatOptions(data.options, handleDiagnosticStep);
                } else {
                    appendChatMessage(data.message, 'bot');
                }
            } catch (error) {
                console.error("Chat error:", error);
                appendChatMessage("Sorry, I'm having trouble connecting.", 'bot');
            }
        }
        
        async function handleDiagnosticStep(answer) {
            if (!diagnosticState.inProgress) return;
            
            try {
                const appCheckToken = (await appCheck.getToken(false)).token;
                const response = await fetch(`${BACKEND_URL}/diagnose-step`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-Firebase-AppCheck': appCheckToken },
                    body: JSON.stringify({ 
                        topic: diagnosticState.topic, 
                        node_id: diagnosticState.node_id, 
                        answer: answer 
                    })
                });
                const data = await response.json();

                if (data.status === 'diagnostic_continue') {
                    diagnosticState.node_id = data.node_id;
                    appendChatMessage(data.question, 'bot');
                    showChatOptions(data.options, handleDiagnosticStep);
                } else if (data.status === 'diagnostic_end') {
                    appendChatMessage(data.diagnosis, 'bot');
                    diagnosticState = { inProgress: false, topic: null, node_id: null };
                } else {
                    appendChatMessage(data.message || "Something went wrong.", 'bot');
                    diagnosticState = { inProgress: false, topic: null, node_id: null };
                }
            } catch (error) {
                console.error("Diagnostic step error:", error);
                appendChatMessage("Sorry, I'm having trouble with the diagnosis.", 'bot');
                diagnosticState = { inProgress: false, topic: null, node_id: null };
            }
        }

        function setupProactiveChatListener(uid) {
            if (proactiveChatListener) proactiveChatListener();
            
            const proactiveQuery = db.collection('proactive_chats')
                .where('uid', '==', uid)
                .where('read', '==', false)
                .orderBy('timestamp', 'desc')
                .limit(1);

            proactiveChatListener = proactiveQuery.onSnapshot(snapshot => {
                snapshot.docChanges().forEach(change => {
                    if (change.type === 'added') {
                        change.doc.ref.update({ read: true });

                        const chatData = change.doc.data();
                        
                        chatWindow.classList.add('open');
                        appendChatMessage(chatData.initial_message, 'bot');

                        showChatOptions(["Yes, help diagnose", "No, thanks"], (answer) => {
                            if (answer === "Yes, help diagnose") {
                                sendChatMessage(chatData.topic.replace(/_/g, " "));
                            }
                        });
                    }
                });
            }, error => {
                console.error("Error in snapshot listener:", error);
            });
        }
        
        function changeMonth(monthIndex) {
            currentDate.setMonth(monthIndex);
            header.textContent = `${currentDate.toLocaleString('default', { month: 'long' })} ${currentDate.getFullYear()}`;
            highlightActiveMonth();
            Object.keys(dataTypesConfig).forEach(k => dataTypesConfig[k].initialized = false);
            handleGridSelection(-1); 
            switchTab(activeTab);
        }

        function changeYear(offset) {
            currentDate.setFullYear(currentDate.getFullYear() + offset);
            yearLabel.textContent = currentDate.getFullYear();
            header.textContent = `${currentDate.toLocaleString('default', { month: 'long' })} ${currentDate.getFullYear()}`;
            Object.keys(dataTypesConfig).forEach(k => dataTypesConfig[k].initialized = false);
            handleGridSelection(-1);
            switchTab(activeTab);
        }

        function buildMonthButtons() {
            monthsDiv.innerHTML = '';
            ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'].forEach((m, i) => {
                const btn = document.createElement('button');
                btn.textContent = m;
                btn.onclick = () => changeMonth(i);
                monthsDiv.appendChild(btn);
            });
            highlightActiveMonth();
        }

        function highlightActiveMonth() {
            [...monthsDiv.querySelectorAll('button')].forEach((btn, i) => {
                btn.classList.toggle('active', i === currentDate.getMonth());
            });
        }

        function getMonthDates(date) {
            var y = date.getFullYear(), m = date.getMonth();
            return Array.from({length: new Date(y, m + 1, 0).getDate()}, (_, i) => `${y}-${String(m + 1).padStart(2, '0')}-${String(i + 1).padStart(2, '0')}`);
        }

        function toggleDarkMode(isInitialLoad = false) {
            const isDark = document.getElementById('darkToggle').checked;
            document.body.classList.toggle('dark', isDark);
            if(!isInitialLoad) localStorage.setItem('darkMode', isDark);
        }
        
        auth.onAuthStateChanged(async (user) => {
            try {
                if (user) {
                    currentUID = user.uid;
                    currentHospital = localStorage.getItem("hospitalName");
                    document.getElementById("hospitalName").textContent = currentHospital;

                    const centerId = currentHospital?.toLowerCase().replace(/ /g, '_');
                    if (centerId) {
                        const monthsRef = db.collection("linac_data").doc(centerId).collection("months");
                        const snapshot = await monthsRef.orderBy(firebase.firestore.FieldPath.documentId(), "desc").limit(1).get();
                        if (!snapshot.empty) {
                            lastDataMonth = snapshot.docs[0].id.replace("Month_", "");
                        }
                    }
                    
                    yearLabel.textContent = currentDate.getFullYear();
                    header.textContent = `${currentDate.toLocaleString('default', { month: 'long' })} ${currentDate.getFullYear()}`;
                    buildMonthButtons();
                    document.getElementById('prevYearBtn').onclick = () => changeYear(-1);
                    document.getElementById('nextYearBtn').onclick = () => changeYear(1);
                    document.getElementById('logoutBtn').onclick = logout;
                    const darkToggle = document.getElementById('darkToggle');
                    darkToggle.checked = localStorage.getItem('darkMode') === 'true';
                    toggleDarkMode(true);
                    darkToggle.addEventListener('change', () => toggleDarkMode(false));
                    
                    document.getElementById('menu-toggle').addEventListener('click', () => {
                        document.querySelector('.sidebar').classList.toggle('sidebar-visible');
                    });
                    
                    document.getElementById('chat-bubble').onclick = () => chatWindow.classList.toggle('open');
                    document.getElementById('close-chat-btn').onclick = () => chatWindow.classList.remove('open');
                    document.getElementById('chat-input').onkeypress = e => { if (e.key === 'Enter' && !diagnosticState.inProgress) sendChatMessage(); };
                    document.getElementById('send-chat-btn').onclick = () => { if(!diagnosticState.inProgress) sendChatMessage(); };

                    document.getElementById('daily-temp').addEventListener('focus', highlightColumnFromPanel);
                    document.getElementById('daily-pressure').addEventListener('focus', highlightColumnFromPanel);
                    document.getElementById('daily-temp').addEventListener('input', saveEnvData);
                    document.getElementById('daily-pressure').addEventListener('input', saveEnvData);
                    // [NEW] Add blur listeners to clear the highlight
                    document.getElementById('daily-temp').addEventListener('blur', clearColumnHighlight);
                    document.getElementById('daily-pressure').addEventListener('blur', clearColumnHighlight);


                    setupProactiveChatListener(currentUID);
                    
                    switchTab('output');

                } else {
                    window.location.replace("login.html");
                }
            } catch (error) {
                console.error("A critical error occurred during page load:", error);
                alert("A critical error occurred. Please check the console for details.");
                hideLoader();
            }
        });

        window.onclick = function(event) {
            if (event.target == annotationModal) {
                hideAnnotationModal();
            }
        }
    });
  </script>
</body>
</html>
